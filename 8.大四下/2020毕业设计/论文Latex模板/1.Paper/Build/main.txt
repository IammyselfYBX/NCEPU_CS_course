毕 业 设 计（论 文）
题

目

基于 Qume 模拟器移植 rCore 操作系统的
开发与实现

院
系
专
业
班
级
学生姓名
学
号
指导教师

控制与计算机工程学院
计算机科学与技术
计算 1702 班
杨秉学
120171080212
琚贇

二○二一年六月

华北电力大学本科毕业设计（论文）

摘

要

RISC-V 是一款近年来最为流行的开源指令集架构，被广泛应用于各个场景。
Linux 也是一个十分流行的开源操作系统内核。本实验采取 Qemu 虚拟化技术模
拟 RISC-V 指令环境，解决跨平台的模型部署和运行问题。在上面进行移植 Linux
操作系统，尝试在上面编译安装程序，并对 RISC-V 指令集以及操作系统，计算
机组成原理，计算机体系结构综合知识进行回顾与总结。
关键字：RISC-V；Qemu；linux；系统移植；

I

华北电力大学本科毕业设计（论文）

ABSTRACT
This experiment is a confirmative experiment. By porting Linux to RISC-V platform, the basic functions can be realized. And this opportunity is used to review all the
contents learned in the undergraduate course
KEY WORDS:RISC-V,Qemu,linux

II

目
摘

录

要 ......................................................................................................

I

ABSTRACT .................................................................................................

II

第 1 章 绪论 ....................................................................................................

1

1.1 课题研究背景和意义...............................................................................

1

1.2 国内外研究现状 .....................................................................................

1

1.3 本文研究内容 ........................................................................................

2

第 2 章 RISC-V 体系架构...................................................................................

3

2.1 指令表示方法与指令格式 ........................................................................

3

2.1.1 R 指令 .........................................................................................

3

2.1.2 I 指令 ..........................................................................................

3

2.1.3 S 指令 .........................................................................................

4

2.1.4 B 指令 .........................................................................................

4

2.1.5 U 指令 .........................................................................................

4

2.1.6 J 指令 ..........................................................................................

4

2.2 流水线..................................................................................................

4

2.2.1 处理器性能度量方法 ......................................................................

4

2.2.2 流水线的设计 ...............................................................................

5

2.2.3 结构冒险......................................................................................

5

2.2.4 数据冒险......................................................................................

5

2.2.5 控制冒险......................................................................................

6

第 3 章 Qemu & KVM 基本原理 ..........................................................................

7

3.1 虚拟化..................................................................................................

7

3.1.1 软件虚拟化 ..................................................................................

7

3.1.2 硬件虚拟化 ..................................................................................

7

3.2 硬件虚拟化介绍 .....................................................................................

7

3.2.1 CPU 虚拟化 ..................................................................................

7

3.2.2 内存虚拟化 ..................................................................................

8

3.2.3 I/O 虚拟化....................................................................................

9

3.3 KVM & Qemu 模拟器介绍 ....................................................................... 10
3.3.1 KVM 内核模块 ............................................................................. 11
3.3.2 QEMU 用户态设备模拟 .................................................................. 12
3.4 KVM 上层管理工具 ................................................................................ 13
3.4.1 libvirt .......................................................................................... 13
3.4.2 virsh ............................................................................................ 13

III

3.4.3 virt-manager .................................................................................. 13
第 4 章 实验流程 .............................................................................................. 14
4.1 前期准备 .............................................................................................. 14
4.2 Qemu 搭建 ............................................................................................ 14
4.3 移植过程介绍 ........................................................................................ 14
4.3.1 交叉工具链的准备 ......................................................................... 14
4.3.2 创建根文件系统 ............................................................................ 16
4.4 最终效果 .............................................................................................. 16
第 5 章 与前人比较........................................................................................... 18
5.1 不足..................................................................................................... 18
第 6 章 总结 .................................................................................................... 19
...................................................................................................... 20

录 ......................................................................................................

21

...................................................................................................... 22

华北电力大学本科毕业设计（论文）

1
1.1 课题研究背景和意义
在“中兴事件”刚过没多久，某些国家就开始发动“华为事件”，进行各种制裁，这对
我国半导体产业的打击极大，是可忍孰不可忍，放眼整个产业链，我们国家连一个像样的
成熟指令集架构都没有，连一个可大规模商用的操作系统都没有，当我们想研究开发产品
竟然还需要看别人脸色来得到授权，这是莫大的耻辱。为什么外国人能做出来，我们就做
不出来，我们也并不比他们差什么。所以，我觉得我有必要研究这样的问题了，这就是为
什么我毕业设计要研究操作系统，指令集这样的内容，帝国主义封锁我们，不让我们发展，
但我偏偏就要研究这些偏底层的原理。
首先是选择的指令集——Risc-v，它是一个最近流行基于 RISC 的指令集架构，它就类
似于软件领域开源的 linux 一样，Risc-V 也有在很多领域发挥作用，如果将 linux 与 RiSC-V
结合一起来发展的话，我们就可以利用已有的生态，站在巨人们的肩膀上完成自己的目标，
而且开源的话可以集思广益，大家一起参与进来，在这个过程中可以发现自己的不足，然
后改正，这本身就是一个学习提升的过程，是一个充满意义的事情。

1.2 国内外研究现状
RISC-V 最早是由国外的加州大学伯克利分校（University of California, Berkeley）开发
的，并且经过多次完善最终形成的第 5 代精简指令集 (RISC), 并于 2014 年发布，它集百家
之长吸收了 ARM,MIPS,x86 和 PowerPC 的经验，是一个模块化的可扩展的指令集，面对不
同的应用场景，可以通过组合他的不同模块满足不同需求，而且相比传统的 ARM 指令是
不允许做指令集的扩展，RISC-V 是支持指令扩展的，最关键的还没有历史包袱，体现在这
几个方面，因为我们看到一些传统的 ARM 架构，篇幅有数千页，RISC-V 架构只有小于三
百页，指令数目，ARM 是指令数繁多，不同的架构分支彼此不兼容。RISC-V 一套指令集
支持所有架构，基本指令集仅 40 余条指令，以此为共有基础，加上其他长用模块指令集
总数也仅几十条。易实现性，硬件实现的复杂性度高。RISC-V 是硬件设计与编译器实现
非常简单。
虽然我们的学校的确与美帝之间存在差距，但是这都不算什么，因为就算他们现在比
我们发展要超前也这不代表以后永远都会领先我们，如果我们把精力，资源放在这方面，
假以时日我们是会迎头赶上的，也可以做出属于自己的产业链。
目前国外 SiFive 公司做的不错，提供给予 RISC-V 指令集架构的商业化处理器 IP、开
发工具以及芯片的解决方案，并于 2018 年在中国注册独立公式 SaiFan 用于在中国市场为
客服提供服务；Green WavesIoT 低功耗边缘应用处理器，也是采用 RISC-V 来做的 [1]。
我想 RISC-V 很有可能能够成为真正实现国产自主的指令集架构，国产芯片之前的创
新领域都是用各种各样国外授权的指令集架构，其先后投入大概十几年的时间发展，这些
国外的指令集架构，从本质上来讲是授权，一方面是要给国外的商业公司付费，另一方面

1

华北电力大学本科毕业设计（论文）

来讲，外国企业可以停止授权。如果我们国家自己定义一套自己的指令集架构，本身又没
有太大的意义，因为处理器架构必须要是一个全球范围内的普世通用的，才能获得全球范
围内的通用生态的支持。所以，在以前的背景下，国产自主可控与普世通用生态存在天然
的矛盾，现在有了 RISC-V，其实能够很好的解决这个问题。
国内的芯来科技模仿 SiFive 做的也不错，提供多个 RISC-V IP，并提供蜂鸟 E203 开发
板；中国台湾的 Andes 也是用 RISC-V 来做自己的芯片产品；阿里的平头哥收购了中天微
并展开了自己的研究, 就在 2021 年阿里推出的全球最强的 RISC-V 芯片玄铁 910，在上面
就可以流畅的运行了安卓系统，也就意味着 RISC-V 芯片能够使用现成的、成熟的安卓生
态，生态问题就不用愁了。
最后 RISC-V 对 IoT 的发展也很大，现在 IoT 和边缘计算是碎片化，越来越以应用为
中心，不像以前以芯片为中心，这样就造成以应用公司和模组公司为中心的趋势，而替代
了传统的以芯片公司为中心的模式，传统以芯片公司为中心的模式难以满足现在的趋势。
以 ARM 为例，其发布周期长，售价昂贵，用同样的 IoT，会面临同质化竞争的问题，由于
价格昂贵，使得创新的门槛非常高昂，基本上很大的公司和有技术能力的公司才能最早买
到 IP，难以快速响应碎片化的 IoT 和边缘计算能力的需求。

1.3 本文研究内容
本文主要内容在 Qemu 模拟器上将 linux 试图移植到 RISC-V 的平台上面，并逐步实现
实验环境的搭建，交叉工具链的编译，完善文件系统，安装网络协议栈等现代操作系统应
该具备的基本功能，并解决在此过程中遇到的种种挑战，种种报错以及解决方案，最后运
行一个 RISC-V 指令集的简单程序验证一下是否移植成功。
虽然，已经国内已经有人做出了基于 RISC-V 处理器内核，linus 也把 riscv-linux 合并
到 Linux 的主分支上了，但是我这个毕设的内容就是自己想进行一遍，是验证性的实验，虽
然我也知道我现在做的这些事情看来有些微不足道，但是我想既然我已经努力开始做了，
就已经具有了加速度，根据 v = v0 + at 让子弹再飞一会儿，最终就会获得丰收的成绩。

2

华北电力大学本科毕业设计（论文）

2

RISC-V

依据 David A. Patterson 的著作 Computer Organization and Design RISC-V Edition [2] 以
及浙江大学刘鹏博导的公开课 [3] 作为参考理解。

2.1 指令表示方法与指令格式
其实抛开课堂上 PPT 枯燥的概念，如果把计算机比作一个正在说话的人，那么指令就
是那个人每句话中的每一个单词，而指令集就是全部词汇所构成的词汇表，也正是有指令
集的存在，计算机才能实现“开口说话”与沟通，接下来介绍一下 RISC-V 的常用指令。

2.1.1 R 指令
R 指令的功能是用于处理处理器内部的寄存器与寄存器之间算数运算的。
一条 R 型指令的格式划分如图2- 1所示，一个 R 型指令可划分为 6 个域，其中 31-25
这 7bit 宽的是功能码 7，24-20 这 5 为是源寄存器 2，19-15 这 5 为是源寄存器 1,14-12 这
3bit 宽的是功能码 3，11-7 这 5bit 宽的目的寄存器 rd，6-0 这 7 位宽的操作码 (部分规定了
该指令是什么指令)。

图 2- 1 R 型指令格式的划分, 其中每个域中的文字表示该域的名称；域上的数字表示，该域的起始与终
止位置；每个域下面的数字，表示每个域所占据的 bit 位数

所有 R 指令的 opcode 部分都是 2 进制数：0110011，funct7 与 funct3 是和 opcode 结合
起来一起使用的，三者组合一起规定指令的操作。
rs1，rs2 是源寄存器 (Source Rggister)，用于存放操作数的源地址的，rd 是目的寄存器
(Destination Rggister)，指定接收结果值的寄存器编号，这三个寄存器都存放 5 位无符号整
数 (对应十进制 25 = 32)，对应 0 31 的通用寄存器中的其中一个。

2.1.2 I 指令
I 指令是用于寄存器与立即数之间算数运算和读取的
其实如果是我自己设计指令架构，我很有可能将操作寄存器，操作数用一个指令全部
实现，但是有一个问题，就是指令中的位长，比方说 R 指令的源地址和目的地址才 5bit，最
多就能表示 10 进制的 32 位，那要是操作数字就显得有些有限；但是如果你把指令中的位
长加长的话，就会造成可以表示的 10 进制数太多，但是寄存器就 32 了，造成不必要的浪
费。
3

华北电力大学本科毕业设计（论文）

所以，I 型指令可以在 R 型指令的基础上做一些稍微的改动即可，如图2- 2所示。

图 2- 2 I 型指令就是把 R 型指令的前两个域合并成一个了 12 位的有符号数

2.1.3 S 指令
用于写存储器的

2.1.4 B 指令
用于分支转移操作的，其实是 S 指令的一个变体，之前也叫 SB 指令

2.1.5 U 指令
用于高 20-bit 位立即数操作

2.1.6 J 指令
用于跳转操作，其实是 U 指令的一个变体，之前也叫 UJ 指令

2.2 流水线
2.2.1 处理器性能度量方法
首先，我认为在我们研究之前应该明确我们常说的提高性能是指什么，是表示更快的
响应时间？从而更快的完成需要执行的任务？还是单位时间内能完成更多的任务？还是使
用寿命更长一些？
我觉得性能的本质是——
Instructions
Cycles
T ime
T ime
=
∗
∗
P rogram
P rogram
Instruction Cycle
公式 (2- 1) 是与处理器性能有关的定理

4

(2- 1)

华北电力大学本科毕业设计（论文）

2.2.2 流水线的设计
处理器执行一条指令的步骤——取指，译码，执行，访存，写回。

2.2.3 结构冒险
造成这个冒险的原因是硬件不支持同一周期执行多条指令
这个也比较好解决 1. 让其他阻塞一下等待硬件空闲下来在使用，2. 要么就是多添加点
硬件。

2.2.4 数据冒险
导致数据冒险发生简言之就是不同指令之间存在数据的关联，造成了无法提供指令执
行所需的数据，进而指令不能在预期的时钟周期内执行。
解决方案就是 1. 让其他阻塞一下等待数据使用完在使用，2. 增加一个旁路 (bypassing),
这样的好处就是不需要等待指令完成就可以超市解决数据冒险。如图2- 3 所示，第一条 add
指令执行 EX 阶段的输出前递到 sub 指令的 EX 阶段的输入，替换 sub 指令在第二阶段督
促的寄存器 X1 的值。

图 2- 3 这张图片就显示了旁路的效果

但是有时尽管使用了旁路，也不可避免的需要流水线停

(pipeline Stall)，俗称

(bubble)，图2- 4就是 load 指令执行之后，紧跟着一条需要使用他结果的 R 型指令

图 2- 4 这张就表示有时即使使用旁路，也许要阻塞等待

5

华北电力大学本科毕业设计（论文）

2.2.5 控制冒险
这种冒险发生在根据一条指令的结果判断接下来要执行的分支程序。如图2- 5所示

图 2- 5 控制冒险

解决方法 1. 阻塞等待，2. 采用分支预测，要是预测对了，就继续执行，如图2- 6；如
果预测错了，流水线清空刚才加载错误的指令，重新在装载正确的指令，如图2- 7。

图 2- 6 分支预测：预测成功

图 2- 7 分支预测：预测失败

6

华北电力大学本科毕业设计（论文）

3

Qemu & KVM

3.1 虚拟化
根据维基百科关于虚拟化的定义是：“In computing，virtualization refers to the act of
creating a virtual(rather than actual)version of something，including virtual computer hardware
platforms，storage devices，and computer network resources。”
（在计算机领域，虚拟化指创
建某事物的虚拟（而非实际）版本，包括虚拟的计算机硬件平台、存储设备，以及计算机
网络资源）可见，虚拟化是一种资源管理技术，它将计算机的各种实体资源（CPU、内存、
存储、网络等）予以抽象和转化出来，并提供分割、重新组合，以达到最大化利用物。

3.1.1 软件虚拟化
就是 Qemu 来实现 VMM 层，通过纯软件的环境来模拟执行客户机里的指令。Qemu
是软件层面实现二进制翻译 (二进制翻译 (binary translation) 是指将使用某套指令集的二进
制代码转换成基于另一套指令集的。) 出目标平台代码交给客户机，客户机的每一条目标
平台指令都会被 QEMU 截取, 并翻译成宿主机平台的指令, 然后交给实际的物理平台执行。

3.1.2 硬件虚拟化
这里以 x86 结构为例，Intel 在 2005 年就加入硬件虚拟化的支持——Intel VT。简单来
说就是计算机硬件本身有让客户机指令独立执行的能力，不完全需要 VMM 截获重定向。
其实客户机在 Linux 上就是一个进程，客户机访问自己的物理内存，实际上就是 Linux
内核管理的虚拟内存，以前是使用软件实现客户机虚拟地址 (GVA) 到客户机物理地址
(GPA) 再到宿主机虚拟地址 (HVA) 最后到宿主机物理地址 (HPA) 的四步转换，这个机制也
称为“影子页表”，但是执行代价很大，后来这种靠软件实现的方式被硬件逻辑取代，这就
是 Intel 的 EPT 技术 (或者 AMD 的 NPT 技术)，靠硬件自动算出 GPA 到 HPA 的过程。

3.2 硬件虚拟化介绍
3.2.1 CPU 虚拟化
Intel 在处理器级别提供了对虚拟化技术的支持，被称为 VMX（virtual-machine extensions）
。有两种 VMX 操作模式：VMX 根操作（root operation）与 VMX 非根操作（non-root
operation）
。作为虚拟机监控器中的 KVM 就是运行在根操作模式下，而虚拟机客户机的整
个软件栈（包括操作系统和应用程序）则运行在非根操作模式下。进入 VMX 非根操作模
式被称为“VM Entry”；从非根操作模式退出，被称为“VM Exit”。
VMX 的根操作模式与非 VMX 模式下最初的处理器执行模式基本一样，只是它现在
支持了新的 VMX 相关的指令集以及一些对相关控制寄存器的操作。VMX 的非根操作模
式是一个相对受限的执行环境，为了适应虚拟化而专门做了一定的修改；在客户机中执行
的一些特殊的敏感指令或者一些异常会触发“VM Exit”退到虚拟机监控器中，从而运行
7

华北电力大学本科毕业设计（论文）

在 VMX 根模式。正是这样的限制，让虚拟机监控器保持了对处理器资源的控制。
一个虚拟机监控器软件的最基础的运行生命周期及其与客户机的交互如图 3- 1 所示。
软件通过执行 VMXON 指令进入 VMX 操作模式下；在 VMX 模式下通过 VMLAUNCH
Guest1

Guest0

VM Entry

VM Entry
VM Exit

VMXON

VM Exit

VMM(Hypervisor)

VMXOFF

图 3- 1 VMM 与 Guest 之间的交互

和 VMRESUME 指令进入客户机执行模式，即 VMX 非根模式；当在非根模式下触发 VM
Exit 时，处理器执行控制权再次回到宿主机的虚拟机监控器上；最后虚拟机监控可以执行
VMXOFF 指令退出 VMX 执行模式。
逻辑处理器在根模式和非根模式之间的切换通过一个叫作 VMCS（virtual-machinecontrol
data structure）的数据结构来控制；而 VMCS 的访问是通过 VMCS 指针来操作的。VMCS
指针是一个指向 VMCS 结构的 64 位的地址，使用 VMPTRST 和 VMPTRLD 指令对 VMCS
指针进行读写，使用 MREAD、VMWRITE 和 VMCLEAR 等指令对 VMCS 实现配置。
对于一个逻辑处理器，它可以维护多个 VMCS 数据结构，但是在任何时刻只有一个
VMCS 在当前真正生效。多个 VMCS 之间也是可以相互切换的，VMPTRLD 指令就让某
个 VMCS 在当前生效，而其他 VMCS 就自然成为不是当前生效的。一个虚拟机监控器会
为一个虚拟客户机上的每一个逻辑处理器维护一个 VMCS 数据结构。

3.2.2 内存虚拟化
内存虚拟化的目的是给虚拟客户机操作系统提供一个从 0 地址开始的连续物理内存空
间，同时在多个客户机之间实现隔离和调度。
在虚拟环境下内存地址如图 3- 2 所示。
内存虚拟化就是要将客户机虚拟地址（GVA）转化为最终能够访问的宿主机上的物理
地址（HPA）
。对于客户机操作系统而言，它不感知内存虚拟化的存在，在程序访问客户机
中虚拟地址时，通过 CR3 寄存器可以将其转化为物理地址，但是在虚拟化环境中这个物理
地址只是客户机的物理地址，还不是真实内存硬件上的物理地址。所以，虚拟机监控器就
需要维护从客户机虚拟地址到宿主机物理地址之间的一个映射关系，在没有硬件提供的内
存虚拟化之前，这个维护映射关系的页表叫作影子页表（Shadow Page Table）
。内存的访问
和更新通常是非常频繁的，要维护影子页表中对应关系会非常复杂，开销也较大。同时需
要为每一个客户机都维护一份影子页表，当客户机数量较多时，其影子页表占用的内存较
大也会是一个问题。
8

华北电力大学本科毕业设计（论文）

Guest OS
Guest Virtual Address

Guest Physical Address

Host Virtual Address

Host Physical Address
Virtual Machine Monitor
图 3- 2 虚拟化环境下的内存地址

Intel CPU 在硬件设计上就引入了 EPT（Extended Page Tables，扩展页表）
，从而将客户
机虚拟地址到宿主机物理地址的转换通过硬件来实现。当然，这个转换是通过两个步骤来
实现的，如图 2-3 所示。首先，通过客户机 CR3 寄存器将客户机虚拟地址转化为客户机物
理地址，然后通过查询 EPT 来实现客户机物理地址到宿主机物理地址的转化。EPT 的控制
权在虚拟机监控器中，只有当 CPU 工作在非根模式时才参与内存地址的转换。使用 EPT
后，客户机在读写 CR3 和执行 INVLPG 指令时不会导致 VM Exit，而且客户页表结构自身
导致的页故障也不会导致 VM Exit。所以通过引入硬件上 EPT 的支持，简化了内存虚拟化
的实现复杂度，同时也提高了内存地址转换的效率。

3.2.3 I/O 虚拟化
在虚拟化的架构下，虚拟机监控器必须支持来自客户机的 I/O 请求。通常情况下有以
下 4 种 I/O 虚拟化方式。1）设备模拟：在虚拟机监控器中模拟一个传统的 I/O 设备的特性，
比如在 QEMU 中模拟一个 Intel 的千兆网卡或者一个 IDE 硬盘驱动器，在客户机中就暴露
为对应的硬件设备。客户机中的 I/O 请求都由虚拟机监控器捕获并模拟执行后返回给客户
机。
2）前后端驱动接口：在虚拟机监控器与客户机之间定义一种全新的适合于虚拟化环
境的交互接口，比如常见的 virtio 协议就是在客户机中暴露为 virtio-net、virtio-blk 等网络
和磁盘设备，在 QEMU 中实现相应的 virtio 后端驱动。
3）设备直接分配：将一个物理设备，如一个网卡或硬盘驱动器直接分配给客户机使
用，这种情况下 I/O 请求的链路中很少需要或基本不需要虚拟机监控器的参与，所以性能
很好。
4）设备共享分配：其实是设备直接分配方式的一个扩展。在这种模式下，一个（具有
9

华北电力大学本科毕业设计（论文）

特定特性的）物理设备可以支持多个虚拟机功能接口，可以将虚拟功能接口独立地分配给
不同的客户机使用。如 SR-IOV 就是这种方式的一个标准协议。
表3- 1展示了这 4 种 I/O 虚拟化方式的优缺点，前两种都是纯软件的实现，后两种都需
要特定硬件特性的支持。
优点
设备模拟

兼容性好，不需要额外驱动

前后端接口

性能有所提升

设备直接分配

性能非常好

设备共享分配

1. 性能非常好
2. 单个设备可共享

缺点
1. 性能较差
2. 模拟设备的功能特性支持不够多
1. 兼容性差一些：依赖客户机总安装特定驱动
2.I/O 压力大时，后端驱动的 CPU 资源占用较高
1. 需要硬件设备的特性支持
2. 单个设备只能分配一个客户机
3. 很难支持动态迁移
1. 所需设备硬件的特性支持
2. 很难支持动态迁移

表 3- 1 常见 I/O 虚拟化方式的优缺点

3.3 KVM & Qemu 模拟器介绍
首先 Qemu(Quick Emulator) 本身并不完全是 KVM 的一部分，它是一套由软件模拟实
现的。
而 KVM(Kernel Virtual Machine) 是有两部分组成，一部分是 Linux 内核的 KVM 模块，
另一块是经过简化后的 Qemu。它能够让 Linux 主机成为一个 Hypervisor（虚拟机监控器）
。
在支持 VMX（Virtual Machine Extension）功能的 x86 处理器中，Linux 在原有的用户模式
和内核模式中新增加了客户模式，并且客户模式也拥有自己的内核模式和用户模式，虚拟
机就是运行在客户模式中。三层结构如图3- 3所示。
Userspace

Guest
客服模式

Kernel

Qemu
Host Userspace
用户模式

IOCTL
System ioctl
KVM-fd

Host Kernel
内核模式

VM ioctl

vCPU ioctl

kvm VM-fd

KVM vCPU-fd

KVM Driver (KVM 内核模块)
Host Kernel
图 3- 3 KVM 三种模式的层次关系

10

华北电力大学本科毕业设计（论文）

KVM 就是在硬件辅助虚拟化技术之上构建起来的虚拟机监控器。
当然，并非要所有这些硬件虚拟化都支持才能运行 KVM 虚拟化，KVM 对硬件最低的
依赖是 CPU 的硬件虚拟化支持。

3.3.1 KVM 内核模块
KVM 模块是 KVM 虚拟化的核心模块，它在内核中由两部分组成：一个是处理器架构
无关的部分，用 lsmod 命令中可以看到，如图 3- 4 所示，叫作 kvm 模块；另一个是处理器
架构相关的部分，在 Intel 平台上就是 kvm_intel 这个内核模块。KVM 的主要功能是初始
化 CPU 硬件，打开虚拟化模式，然后将虚拟客户机运行在虚拟机模式下，并对虚拟客户机
的运行提供一定的支持。

图 3- 4 lsmod

以 KVM 在 Intel 公司的 CPU 上运行为例，在被内核加载的时候，KVM 模块会先初始
化内部的数据结构；做好准备之后，KVM 模块检测系统当前的 CPU，然后打开 CPU 控制
寄存器 CR4 中的虚拟化模式开关，并通过执行 VMXON 指令将宿主操作系统（包括 KVM
模块本身）置于 CPU 执行模式的虚拟化模式中的根模式；最后，KVM 模块创建特殊设备
文件/dev/kvm 并等待来自用户空间的命令。接下来，虚拟机的创建和运行将是一个用户空
间的应用程序（QEMU）和 KVM 模块相互配合的过程。
/dev/kvm 这个设备可以被当作一个标准的字符设备，KVM 模块与用户空间 QEMU
的通信接口主要是一系列针对这个特殊设备文件的 loctl 调用。当然，每个虚拟客户机针
对/dev/kvm 文件的最重要的 loctl 调用就是“创建虚拟机”。在这里，“创建虚拟机”可以
理解成 KVM 为了某个特定的虚拟客户机（用户空间程序创建并初始化）创建对应的内核
数据结构。同时，KVM 还会返回一个文件句柄来代表所创建的虚拟机。针对该文件句柄
的 loctl 调用可以对虚拟机做相应的管理，比如创建用户空间虚拟地址和客户机物理地址
及真实内存物理地址的映射关系，再比如创建多个可供运行的虚拟处理器（vCPU）
。同样，
KVM 模块会为每一个创建出来的虚拟处理器生成对应的文件句柄，对虚拟处理器相应的
文件句柄进行相应的 loctl 调用，就可以对虚拟处理器进行管理。
针对虚拟处理器的最重要的 loctl 调用就是“执行虚拟处理器”。通过它，用户空间准
备好的虚拟机在 KVM 模块的支持下，被置于虚拟化模式中的非根模式下，开始执行二进
制指令。在非根模式下，所有敏感的二进制指令都会被处理器捕捉到，处理器在保存现场
之后自动切换到根模式，由 KVM 决定如何进一步处理（要么由 KVM 模块直接处理，要
么返回用户空间交由用户空间程序处理）。
除了处理器的虚拟化，内存虚拟化也是由 KVM 模块实现的，包括前面提到的使用硬

11

华北电力大学本科毕业设计（论文）

件提供的 EPT 特性，通过两级转换实现客户机虚拟地址到宿主机物理地址之间的转换。
处理器对设备的访问主要是通过 I/O 指令和 MMIO，其中 I/O 指令会被处理器直接截
获，MMIO 会通过配置内存虚拟化来捕捉。但是，外设的模拟一般不由 KVM 模块负责。一
般来说，只有对性能要求比较高的虚拟设备才会由 KVM 内核模块来直接负责，比如虚拟
中断控制器和虚拟时钟，这样可以大量减少处理器模式切换的开销。而大部分的输入输出
设备交给下一节将要介绍的用户态程序 QEMU 来负责。

3.3.2 QEMU 用户态设备模拟
QEMU 原本就是一个著名的开源虚拟机软件项目，而不是 KVM 虚拟化软件的一部分。
与 KVM 不同，QEMU 最初实现的虚拟机是一个纯软件的实现，通过二进制翻译来实现虚
拟化客户机中的 CPU 指令模拟，所以性能比较低。但是，其优点是跨平台，QEMU 支持在
Linux、Windows、FreeBSD、Solaris、MacOS 等多种操作系统上运行，能支持在 QEMU 本身
编译运行的平台上就实现虚拟机的功能，甚至可以支持客户机与宿主机并不是同一个架构
（比如在 x86 平台上运行 ARM 客户机）。作为一个存在已久的虚拟机监控器软件，QEMU
的代码中有完整的虚拟机实现，包括处理器虚拟化、内存虚拟化，以及 KVM 也会用到的
虚拟设备模拟（比如网卡、显卡、存储控制器和硬盘等）。
除了二进制翻译的方式，
QEMU 也能与基于硬件虚拟化的 Xen、KVM 结合，
为它们提供
客户机的设备模拟。通过与 KVM 的密切结合，让虚拟化的性能提升得非常高，在真实的企
业级虚拟化场景中发挥重要作用，
所以我们通常提及 KVM 虚拟化时就会说“QEMU/KVM”
这样的软件栈。
最早期的 KVM 开发者们为了简化软件架构和代码重用，根据 KVM 特性在 QEMU 的
基础上进行了修改（当然这部分修改已经合并回 QEMU 的主干代码，故现在的 QEMU 已
原生支持 KVM 虚拟化特性）
。从图 2-8 可以看出，每一个虚拟客户机在宿主机中就体现为
一个 QEMU 进程，而客户机的每一个虚拟 CPU 就是一个 QEMU 线程。虚拟机运行期间，
QEMU 会通过 KVM 模块提供的系统调用进入内核，由 KVM 模块负责将虚拟机置于处理
器的特殊模式下运行。遇到虚拟机进行 I/O 操作时，KVM 模块会从上次的系统调用出口
处返回 QEMU，由 QEMU 来负责解析和模拟这些设备。
从 QEMU 角度来看，也可以说 QEMU 使用了 KVM 模块的虚拟化功能，为自己的虚
拟机提供硬件虚拟化的加速，从而极大地提高了虚拟机的性能。除此之外，虚拟机的配置
和创建，虚拟机运行依赖的虚拟设备，虚拟机运行时的用户操作环境和交互，以及一些针
对虚拟机的特殊技术（如：动态迁移），都是由 QEMU 自己实现的。
QEMU 除了提供完全模拟的设备（如：e1000 网卡、IDE 磁盘等）以外，还支持 virtio 协
议的设备模拟。virtio 是一个沟通客户机前端设备与宿主机上设备后端模拟的比较高性能
的协议，在前端客户机中需要安装相应的 virtio-blk、virtio-scsi、virtio-net 等驱动，而 QEMU
就实现了 virtio 的虚拟化后端。QEMU 还提供了叫作 virtio-blk-data-plane 的一种高性能的
块设备 I/O 方式，它最初在 QEMU 1.4 版本中被引入。virtio-blk-data-plane 与传统 virtio-blk
相比，它为每个块设备单独分配一个线程用于 I/O 处理，data-plane 线程不需要与原 QEMU
执行线程同步和竞争锁，而且它使用 ioeventfd/irqfd 机制，同时利用宿主机 Linux 上的 AIO
12

华北电力大学本科毕业设计（论文）

（异步 I/O）来处理客户机的 I/O 请求，使得块设备 I/O 效率进一步提高。
总之，QEMU 既是一个功能完整的虚拟机监控器，也在 QEMU/KVM 的软件栈中承担
设备模拟的工作。

3.4 KVM 上层管理工具
3.4.1 libvirt
libvirt 是使用最广泛的对 KVM 虚拟化进行管理的工具和应用程序接口，已经是事实
上的虚拟化接口标准，本节后部分介绍的其他工具都是基于 libvirt 的 API 来实现的。作为
通用的虚拟化 API，libvirt 不但能管理 KVM，还能管理 VMware、Hyper-V、Xen、VirtualBox
等其他虚拟化方案。

3.4.2 virsh
virsh 是一个常用的管理 KVM 虚拟化的命令行工具，对于系统管理员在单个宿主机上
进行运维操作，virsh 命令行可能是最佳选择。virsh 是用 C 语言编写的一个使用 libvirt API
的虚拟化管理工具，其源代码也是在 libvirt 这个开源项目中的。

3.4.3 virt-manager
virt-manager 是专门针对虚拟机的图形化管理软件，底层与虚拟化交互的部分仍然是
调用 libvirt API 来操作的。virt-manager 除了提供虚拟机生命周期（包括：创建、启动、停止、
打快照、动态迁移等）管理的基本功能，还提供性能和资源使用率的监控，同时内置了 VNC
和 SPICE 客户端，方便图形化连接到虚拟客户机中。virt-manager 在 RHEL、CentOS、Fedora
等操作系统上是非常流行的虚拟化管理软件，在管理的机器数量规模较小时，virt-manager
是很好的选择。因其图形化操作的易用性，成为新手入门学习虚拟化操的首选管理软件。

13

华北电力大学本科毕业设计（论文）

4
本实验是依据 Github 上的项目 [4] 来实现的，但是该项目已经有三年没有更新了，很多
内容已经不适用了，比方说当时采用 Linux Kernel v4.4，当时 Linux 主分支不支持 RISC-V，
但是这里采用的是 Linux Kernel v5.*，此时 Linux 主分支已经支持了 RISC-V 架构了；还有
就是 Qemu 在 4.* 的时候需要自己编译 OpenSBI ，但是在 Qemu 5.* 以后就内嵌 OpenSBI，
一些流程也有所改变，但是清楚 Linux 启动流程就可以了，详细参考 [5]。

4.1 前期准备
本实验环境是在 Intel 的 x86 平台，实验运行系统是 Gentoo linux 的，系统具体信息如
图4- 1 所示，实验所需的软件信息如图4- 2。

图 4- 1 实验操作系统

4.2 Qemu 搭建

在 Gentoo 官方的 Wiki 手册中可以参考 [6]，
具体可以参考 https://www.bilibili.com/video/BV1ny4y1i7
还要修改 USE 来支持 RISC-V。

4.3 移植过程介绍
Linux 在 v5.0 以后，既然内核已经可以支持 RISC-V，这样只需要编译内核的时候，添
加选项 ARCH = riscv 参数即可。

4.3.1 交叉工具链的准备
我这里是使用 GNU 提供的交叉工具链。
在 GNU 提供的 riscv − gnu − toolchain 工具链里，参考 GNU 说明文档，只需要在 x86
平台上交叉编译出 RISC-V 的所需的工具即可。

14

华北电力大学本科毕业设计（论文）

图 4- 2 实验所需软件信息

15

华北电力大学本科毕业设计（论文）

4.3.2 创建根文件系统
对于文件系统格式化，采用通用的 ext4 格式，挂载到临时文件夹，并创建根目录所需
的一切结构文件夹，结束后要将临时文件夹删除。

4.4 最终效果
最终启动结果如图4- 3所示，可以支持 SSH 访问，如图4- 4所示，并且可以执行程序如
图4- 5所示。

图 4- 3 运行成功

为了验证能否正常的使用，我编译个一个演示程序进行运行，结果如图4- 5所示，可
以正常运行成功。

16

华北电力大学本科毕业设计（论文）

图 4- 4 支持 SSH 网络连接

图 4- 5 运行程序

17

华北电力大学本科毕业设计（论文）

5
本实验以前有人在 Github 上已经实现了，并且发布成项目 [4] ，但是在实验工程已经
三年多没有更新，在根据 README 文档的时候发现其中很多功能已经失效了，很多步骤
也会报错，但我依旧凭借着大学几年下来所学的知识进行解决，并成功运行一个演示程序。
通过该课程设计，让我对 Qemu 有了更深的理解，再加上对操作系统底层有更深的理
解，更深体会到编译工具的熟练使用。

5.1 不足
虽然，本文已经可以运行一个程序，但是目前还有如下问题：(1) 图形界面，就是用户
需要使用图形界面的，这样可以更加方便用户使用，但是目前还没有想清楚如何添加图形
界面方法；(2) 需要做横向对比，和 MIPS，ARM 比较，看一下 RISC-V 的平台会提高多少
性能；(3) 其实这个也不算标准的移植，成功运行了，但是不代表日后会不会出现函数库，
以及依赖的问题；

18

华北电力大学本科毕业设计（论文）

6
本文仅仅是利用本科所学知识来进行的一次探索，就是将 Linux 移植到 risc-v 平台上，
内容比较基础，通过本毕设将大学的计算机组成原理，操作系统，计算机体系结构来进行
全方面的强化，最后希望我的一点探索努力可以更好的完善我国在计算机底层领域的长足
发展。

19

华北电力大学本科毕业设计（论文）

[1] ELEXCON 深圳国际电子展. 关于 RISC-V 发展现状与应用分析和介绍 [N], .
[2] PATTERSON D A. Computer Organization and Design RISC-V Edition:The Hardware Software Interface(1st Edition )[M]. [S.l.] : Morgan Kaufmann, April 27, 2017.
[3] 刘鹏. 计算机组成与设计：RISC-V[EB]. .
[4] MICHAELJCLARK. busybear-linux[EB]. 2021.
[5] 杨秉学. 从按下电源开始的一场接力赛 [EB]. .
[6] GENTOO.ORG. Gentoo Qemu[K]. .

20

华北电力大学本科毕业设计（论文）

录
本 毕 设 由 于 篇 幅 有 限， 首 先 是 关
于

Gentoo

Linux

的 部 分 配 置 请 见：

https://www.bilibili.com/video/BV1ny4y1i7G6

的

视 频 演 示。 关 于 本 毕 设 的 实 验 步 骤 请 见：
https://www.bilibili.com/video/BV1QU4y1H7AE。

21

华北电力大学本科毕业设计（论文）

首先，我非常感谢我的家长，从小到大对我的殷勤付出，最终我才能有今天
的收获，是他们的坚持不懈才让本因高考失败造成的创伤尽可能的减轻。其次要
感谢华北电力大学这群功利现实冷酷无情的学生们，他们就是我的好教员，他们
用他们冷漠自私让我明白一个道理“落后就要挨打，贫穷就要挨饿，失语就要挨
骂”，只有站起来而不是跪下去才会有美好的未来；然后，要感谢毛泽东，邓小
平等那些思想领袖，从他们哪里我学到了很多，大学之前没接触过计算机让我刚
来的时候挂了不少课也被与预警过，但是面对这样的内外交迫的处境，
“速战论”
激进思想与“亡国论”的消极思想是不可取的，应该要打持久战，要划分三个阶
段——“战略防御、战略相持、战略反攻”，人民才是根本，要团结一切力量，积
小胜为大胜，最后我在大二结束的暑假就自学完本科全部的内容，从大三开始进
入战略反攻阶段时就轻而易举的把大一大二欠下的课程全部补齐。要走一条将理
论与实践相结合的道路，即知行合一，走一条具有自身情况特色的发展路线；最
后我要感谢琚赟老师，他并不像其他老师那样因为我大一大二基础差而区别对
待，也没有说过“你学习不要的原因就是因为不努力学习，要抓紧学习”仅仅喊
口号并没有提出解决方案，更没有说类似“我当了这么多年老师，你不是我见过
聪明的学生”来让学生听从他的安排，而是让子弹再飞一会儿，给予我更多的自
主权，而不想对待奴隶一样必须催着赶着让去做一件事。

22

